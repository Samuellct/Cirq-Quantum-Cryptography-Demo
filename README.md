# Quantum Computing and Cryptographic Applications

![Python](https://img.shields.io/badge/python-ffdd54?logo=python&logoColor=4f68a8) ![Cirq](https://img.shields.io/badge/cirq-ffae36?logo=data:image/png;base64,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) ![Qiskit](https://img.shields.io/badge/qiskit-6929C4.svg?logo=qiskit&logoColor=white) ![Sympy](https://img.shields.io/badge/sympy-3B5526.svg?logo=sympy&logoColor=white)

## Overview

This project explores the foundations of quantum computing with a focus on cryptographic applications, particularly Shor's algorithm for integer factorization and its implications for RSA encryption security. Quantum computing represents a shift from classical computation through properties like superposition and entanglement. Unlike classical bits that exist in states 0 or 1, qubits exist in superposition states described by $|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$, where $\alpha$ and $\beta$ are complex amplitudes satisfying $|\alpha|^2 + |\beta|^2 = 1$. For an $n$-qubit system, this allows simultaneous access to $2^n$ basis states, which becomes relevant for problems like integer factorization.

## Theoretical Background

### Quantum Gates and Circuits

We implemented quantum circuits using fundamental gates. The Hadamard gate creates superpositions:

$$H = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$$

The CNOT gate creates entanglement between qubits. For a two-qubit system, it's represented as:

$$\text{CNOT} = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix}$$

The Quantum Fourier Transform (QFT) extracts periodicity from quantum states. For an $n$-qubit system:

$$\text{QFT}|j\rangle = \frac{1}{\sqrt{2^n}} \sum_{k=0}^{2^n-1} e^{2\pi ijk/2^n}|k\rangle$$

This transformation is central to Shor's algorithm, enabling period-finding in polynomial time.

### RSA and Factorization

RSA security depends on the difficulty of factoring the product $n = p \times q$ of two large primes. Key generation involves computing $\phi(n) = (p-1)(q-1)$, selecting a public exponent $e$ coprime to $\phi(n)$, and calculating the private exponent $d \equiv e^{-1} \pmod{\phi(n)}$. Encryption transforms plaintext $m$ into ciphertext $c \equiv m^e \pmod{n}$, while decryption recovers $m \equiv c^d \pmod{n}$.

The best classical factorization algorithms have subexponential complexity $O(\exp((64/9)^{1/3} (\ln n)^{1/3} (\ln \ln n)^{2/3}))$. Shor's algorithm reduces this to polynomial time $O((\log n)^3)$ by finding the period of the modular exponentiation function $f(x) = a^x \bmod n$.

## Implementation

### RSA Encryption

We implemented two versions of RSA. The simple version uses SymPy for educational purposes:
```python
def generate_keypair(bits):
    p = sympy.randprime(2**(bits//2), 2**(bits//2 + 1))
    q = sympy.randprime(2**(bits//2), 2**(bits//2 + 1))
    n = p * q
    phi = (p-1) * (q-1)
    
    e = random.randrange(1, phi)
    while sympy.gcd(e, phi) != 1:
        e = random.randrange(1, phi)
    
    d = sympy.mod_inverse(e, phi)
    return ((e, n), (d, n))
```

This function generates primes $p$ and $q$, computes $n$ and $\phi(n)$, then selects $e$ and calculates $d$ as the modular inverse of $e$ modulo $\phi(n)$.

### Shor's Algorithm with Cirq

The quantum phase of Shor's algorithm requires two registers: an $n$-qubit target register and a $2n+3$ qubit exponent register. The core operation is modular exponentiation:
```python
class ModularExp(cirq.ArithmeticGate):
    def apply(self, *register_values: int) -> int:
        target, exponent, base, modulus = register_values
        if target >= modulus:
            return target
        return (target * base**exponent) % modulus
```

This gate implements $U_a|y\rangle = |ay \bmod n\rangle$ controlled by the exponent register. The circuit construction combines initialization, superposition, modular exponentiation, and QFT:
```python
def make_order_finding_circuit(x: int, n: int) -> cirq.Circuit:
    L = n.bit_length()
    target = cirq.LineQubit.range(L)
    exponent = cirq.LineQubit.range(L, 3 * L + 3)
    
    mod_exp = ModularExp([2] * L, [2] * (2 * L + 3), x, n)
    
    return cirq.Circuit(
        cirq.X(target[L - 1]),
        cirq.H.on_each(*exponent),
        mod_exp.on(*target, *exponent),
        cirq.qft(*exponent, inverse=True),
        cirq.measure(*exponent, key='exponent'),
    )
```

After measurement, we apply continued fraction expansion to extract the period $r$:
```python
def process_measurement(result: cirq.Result, x: int, n: int) -> Optional[int]:
    exponent_as_integer = result.data["exponent"][0]
    exponent_num_bits = result.measurements["exponent"].shape[1]
    eigenphase = float(exponent_as_integer / 2**exponent_num_bits)
    
    f = fractions.Fraction.from_float(eigenphase).limit_denominator(n)
    
    if f.numerator == 0:
        return None
    
    r = f.denominator
    if x**r % n != 1:
        return None
    return r
```

### Limitations

We initially attempted implementation with Qiskit but encountered circuit optimization issues. Cirq provided better control over gate decomposition. However, simulating quantum systems requires exponentoial classical resurces, representing an $n$-qubit state needs $2^n$ complex amplitudes. Our simulations succeeded for numbers up to five digits (~17 bits) but exhausted memory beyond that. Factoring cryptographically relevant 2048-bit RSA keys would require millions of physical qubits with error rates below $10^{-15}$, far from current $\sim10^{-3}$ rates.

## Results

The implementation successfully demonstrated Shor's algorithm for small integers. For example, factoring $n = 46875$ yielded $p = 3$ and $q = 15625$ using quantum order-finding. While this doesn't approach real-world key sizes, it verified the algorithm's correctness and highlighted the gap between theoretical quantum advantage and practical implementation.

## References

1. Shor, P. W. (1994). "Algorithms for quantum computation: Discrete logarithms and factoring" *FOCS 1994*, pp. 124-134.
2. Nielsen & Chuang (2010). *Quantum Computation and Quantum Information*. Cambridge University Press.

---

*Project completed as part of Master 1 curriculum at Universit√© Clermont Auvergne.*
